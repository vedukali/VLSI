VHDL code for MOD-10 counter: file name: modn_counter
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity modn_counter is
    generic (
        N : integer := 10  -- modulus (default = 10)
    );
    Port (
        clk   : in  STD_LOGIC;
        reset : in  STD_LOGIC;
        q     : out STD_LOGIC_VECTOR(3 downto 0) -- adjust width if N > 16
    );
end modn_counter;

architecture Behavioral of modn_counter is
    signal count : integer range 0 to N-1 := 0;
begin
    process(clk, reset)
    begin
        if reset = '1' then
            count <= 0;
        elsif rising_edge(clk) then
            if count = N-1 then
                count <= 0;
            else
                count <= count + 1;
            end if;
        end if;
    end process;

    q <= std_logic_vector(to_unsigned(count, 4));
end Behavioral;

Testbench code: file name: modn_counter_tb

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity modn_counter_tb is
end modn_counter_tb;

architecture behavior of modn_counter_tb is
    signal clk   : STD_LOGIC := '0';
    signal reset : STD_LOGIC := '0';
    signal q     : STD_LOGIC_VECTOR(3 downto 0);
begin
    uut: entity work.modn_counter
        generic map (N => 10) -- you can change this (e.g., 6, 12, etc.)
        port map (
            clk   => clk,
            reset => reset,
            q     => q
        );

    -- Clock generation (10 ns period)
    clk_process: process
    begin
        while now < 200 ns loop
            clk <= '0'; wait for 5 ns;
            clk <= '1'; wait for 5 ns;
        end loop;
        wait;
    end process;

    stim_proc: process
    begin
        -- Apply reset
        reset <= '1'; wait for 10 ns;
        reset <= '0'; wait for 10 ns;

        -- Let the counter run
        wait for 150 ns;

        -- Reset again
        reset <= '1'; wait for 10 ns;
        reset <= '0'; wait;

    end process;
end behavior;

